import com.twasyl.slideshowfx.gradle.plugins.gherkin.GherkinPlugin
import com.twasyl.slideshowfx.gradle.plugins.sfxplugin.SlideshowFXPlugin
import org.openjfx.gradle.JavaFXPlugin
import org.sonarqube.gradle.SonarQubePlugin
import org.sonarqube.gradle.SonarQubeTask

import static org.gradle.api.file.DuplicatesStrategy.EXCLUDE

buildscript {
    repositories {
        mavenCentral()
    }
}

plugins {
    id 'idea'
    id 'org.sonarqube'
    id 'build-dashboard'
    id 'sfx-release'
}

idea {
    project {
        languageLevel = project.property('toolchain.language.version')
        vcs = 'Git'
    }
}

allprojects {
    plugins.apply('idea')

    idea {
        module {
            downloadJavadoc = true
        }
    }

    tasks.register("ideaCleanOutput", Delete) {
        description = "Deletes the out directory generated by IDEA."
        group = "Cleanup"

        def out = file("$projectDir/out")
        enabled = out.exists()
        delete = out
    }
}

subprojects {
    def moduleName = project.name.replace("-", ".")

    plugins.withType(JavaPlugin).configureEach {
        project.extensions.getByType(JavaPluginExtension).toolchain {
            languageVersion.set(JavaLanguageVersion.of(project.property('toolchain.language.version')))
        }

        def jvmArgsForTests = ['-Djava.awt.headless=true', '-Dtestfx.headless=true', '-Dprism.order=sw',
                               '-Dtestfx.robot=glass']

        if (com.twasyl.slideshowfx.gradle.Utils.isMac()) {
            jvmArgsForTests.add('-Dprism.verbose=true')
        } else {
            jvmArgsForTests.add('-Dprism.text=t2k')
        }

        sourceSets {
            main {
                java.outputDir = file("$buildDir/production/$moduleName")
                output.resourcesDir = java.outputDir
            }

            integrationTest {
                compileClasspath += sourceSets.main.output
                runtimeClasspath += sourceSets.main.output
            }
        }

        configurations {
            integrationTestImplementation.extendsFrom implementation
            integrationTestRuntimeOnly.extendsFrom runtimeOnly
        }

        dependencies {
            testImplementation "org.junit.jupiter:junit-jupiter-api:${project.property('dependencies.junit.version')}"
            testImplementation "org.junit.jupiter:junit-jupiter-params:${project.property('dependencies.junit.version')}"
            testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${project.property('dependencies.junit.version')}"

            integrationTestImplementation "org.junit.jupiter:junit-jupiter-api:${project.property('dependencies.junit.version')}"
            integrationTestImplementation "org.junit.jupiter:junit-jupiter-params:${project.property('dependencies.junit.version')}"
            integrationTestRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${project.property('dependencies.junit.version')}"
        }

        tasks.withType(JavaCompile).configureEach {
            inputs.property("moduleName", moduleName)
            sourceCompatibility = project.property('toolchain.language.version')
            targetCompatibility = project.property('toolchain.language.version')
            modularity.inferModulePath = true
        }

        tasks.named("compileJava", JavaCompile).configure {
            options.sourcepath = files(sourceSets.main.java.srcDirs, sourceSets.main.resources.srcDirs)
        }

        tasks.withType(Test).configureEach {
            inputs.property("moduleName", moduleName)
            useJUnitPlatform()

            doFirst {
                jvmArgs("--add-exports", "org.junit.platform.commons/org.junit.platform.commons.util=ALL-UNNAMED",
                        "--add-exports", "org.junit.platform.commons/org.junit.platform.commons.logging=ALL-UNNAMED")
                jvmArgs(jvmArgsForTests)
            }
        }

        tasks.withType(Jar).configureEach {
            inputs.property("moduleName", moduleName)
            duplicatesStrategy = EXCLUDE
            manifest {
                attributes += ["Implementation-Vendor": "Thierry Wasylczenko"]
            }
        }

        tasks.register("integrationTest", Test).configure {
            dependsOn 'jar'
            description = 'Runs integration tests.'
            group = 'verification'
            useJUnitPlatform()
            testClassesDirs = sourceSets.integrationTest.output.classesDirs
            classpath = sourceSets.integrationTest.runtimeClasspath

            doFirst {
                options {
                    jvmArgs(jvmArgsForTests)
                }
            }
        }

        tasks.named("check").configure {
            dependsOn(integrationTest)
        }

        idea {
            module {
                outputDir = file("$projectDir/out/production/$moduleName")
                testOutputDir = file("$projectDir/out/test/$moduleName")

                testSourceDirs += project.sourceSets.integrationTest.java.srcDirs
                testResourceDirs += project.sourceSets.integrationTest.resources.srcDirs
            }
        }
    }

    plugins.withType(JavaTestFixturesPlugin).configureEach {
        dependencies {
            testFixturesImplementation "org.junit.jupiter:junit-jupiter-api:${project.property('dependencies.junit.version')}"
            testFixturesImplementation "org.junit.jupiter:junit-jupiter-params:${project.property('dependencies.junit.version')}"
            testFixturesRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${project.property('dependencies.junit.version')}"
        }
    }

    plugins.withType(GherkinPlugin).configureEach {
        dependencies {
            gherkinTestImplementation "org.junit.jupiter:junit-jupiter-api:${project.property('dependencies.junit.version')}"
            gherkinTestImplementation "org.junit.jupiter:junit-jupiter-params:${project.property('dependencies.junit.version')}"
            gherkinTestImplementation "io.cucumber:cucumber-java:${project.property('dependencies.cucumber.version')}"
        }

        idea {
            module {
                testSourceDirs += project.sourceSets.gherkinTest.java.srcDirs
                testResourceDirs += project.sourceSets.gherkinTest.resources.srcDirs
            }
        }
    }

    plugins.withType(SlideshowFXPlugin).configureEach {
        dependencies {
            integrationTestImplementation project(':slideshowfx-plugin-manager')
            integrationTestImplementation testFixtures(project(':slideshowfx-plugin-manager'))
        }

        tasks.named('integrationTest', Test).configure {
            dependsOn 'bundle'
        }
    }

    plugins.withType(JacocoPlugin).configureEach {
        jacoco {
            toolVersion = "0.8.7"
        }

        tasks.withType(JacocoReport).configureEach {
            executionData.setFrom(fileTree("$buildDir/jacoco").include("*.exec"))

            reports {
                csv.enabled = false
                html.enabled = true
                xml.enabled = true
            }

            dependsOn integrationTest
            if (plugins.hasPlugin(GherkinPlugin)) {
                dependsOn gherkinTest
            }
        }

        tasks.named("check").configure {
            project.tasks.withType(JacocoReport).forEach {
                dependsOn it
            }
        }
    }

    plugins.withType(JavaFXPlugin).configureEach {
        javafx {
            version = project.property('dependencies.javafx.version')
        }
    }

    plugins.withType(SonarQubePlugin).configureEach {
        def requiredSourceSets = [sourceSets.test, sourceSets.integrationTest]

        if (plugins.hasPlugin(GherkinPlugin)) {
            requiredSourceSets += sourceSets.gherkinTest
        }

        def testDirs = []
        def jacocoReports = []
        def junitReports = []

        for (set in requiredSourceSets) {
            testDirs.addAll(set.allSource.srcDirs.findAll { it.exists() })

            def resultFile = file("$buildDir/reports/jacoco/${set.name}/jacocoTestReport.xml")
            if (resultFile.exists()) {
                jacocoReports.add(resultFile)
            }

            resultFile = file("$buildDir/reports/tests/${set.name}")
            if (resultFile.exists()) {
                junitReports.add(resultFile)
            }
        }

        sonarqube {
            properties {
                property("sonar.tests", testDirs.join(','))
                property("sonar.coverage.jacoco.xmlReportPaths", jacocoReports.join(','))
                property("sonar.junit.reportPaths", junitReports.join(','))
            }
        }
    }

    tasks.withType(SonarQubeTask).configureEach {
        dependsOn(subprojects.filter { project -> project.pluginManager.hasPlugin("org.sonarqube") }
                .map { project -> project.tasks.named("check") })
    }
}

sonarqube {
    properties {
        property("sonar.host.url", System.getProperty("sonar.host.url", System.getenv("SONAR_HOST_URL")))
        property("sonar.login", System.getProperty("sonar.login", System.getenv("SONAR_LOGIN")))
        property("sonar.projectKey", System.getProperty("sonar.projectKey", System.getenv("SONAR_PROJECT_KEY")))
        property("sonar.organization", System.getProperty("sonar.organization", System.getenv("SONAR_ORGANIZATION")))
        property("sonar.branch.name", System.getProperty("sonar.branch.name", System.getenv("SONAR_BRANCH")))
        property("sonar.sourceEncoding", "UTF-8")
    }
}