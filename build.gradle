buildscript {
    repositories {
        jcenter()
    }
}

plugins {
    id 'org.sonarqube'
}

allprojects {
    repositories {
        jcenter()
        mavenCentral()
    }
}

def stripProjectVersion(String version) {
    if (version.contains("-SNAPSHOT")) {
        return version.replace("-SNAPSHOT", "")
    } else {
        return version
    }
}

def getPlatform() {
    def osProperty = System.properties['os.name'].toLowerCase()

    if (osProperty.startsWith('mac')) {
        return ext.os.MAC
    } else if (osProperty.startsWith('windows')) {
        return ext.os.WINDOWS
    } else if (osProperty.startsWith('linux')) {
        return ext.os.UNIX
    } else {
        return ext.os.UNKNOWN
    }
}

def getArchitecture() {
    return System.properties['os.arch']
}

/**
 * Determine the suffix for a package according the platform and the architecture.
 */
def getPlatformAndArchitecture() {
    return "${getPlatform()}-${getArchitecture()}"
}

def isPlugin(Project project) {
    return project.getPluginManager().hasPlugin('sfx-plugin')
}

/**
 * Get all projects that have a SNAPSHOT version.
 * @return The list of snapshot projects.
 */
def getSnapshotProjects() {
    return allprojects.findAll { it.version.contains('-SNAPSHOT') }
}


ext.os = [
        MAC    : 'osx',
        WINDOWS: 'windows',
        UNIX   : 'unix',
        UNKNOWN: 'unknown'
]

ext.dependencies = [
        asciidoctorj: [version: '1.6.1'],
        box         : [version: '2.26.0'],
        drive       : [version: 'v3-rev20181213-1.28.0'],
        dropbox     : [version: '3.0.11'],
        felix       : [version: '6.0.1'],
        freemarker  : [version: '2.3.28'],
        jsoup       : [version: '1.11.3'],
        junit       : [version: '5.4.0'],
        markdown    : [version: '0.13'],
        mockito     : [version: '2.26.0'],
        monocle     : [version: '8u76-b04'],
        testfx      : [version: '4.0.15-alpha'],
        vertx       : [version: '3.7.0'],
        wikitext    : [version: '3.0.29'],
        zxing       : [version: '3.3.3']
]

subprojects {

    def javaCallback = {
        compileJava {
            sourceCompatibility = JavaVersion.VERSION_1_8
            targetCompatibility = JavaVersion.VERSION_1_8
        }

        sourceSets {
            integrationTest {
                compileClasspath += sourceSets.main.output
                runtimeClasspath += sourceSets.main.output
            }
        }

        configurations {
            integrationTestImplementation.extendsFrom implementation
            integrationTestRuntimeOnly.extendsFrom runtimeOnly
        }

        dependencies {
            testImplementation "org.junit.jupiter:junit-jupiter-api:${rootProject.ext.dependencies.junit.version}"
            testImplementation "org.junit.jupiter:junit-jupiter-params:${rootProject.ext.dependencies.junit.version}"
            testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${rootProject.ext.dependencies.junit.version}"

            integrationTestImplementation "org.junit.jupiter:junit-jupiter-api:${rootProject.ext.dependencies.junit.version}"
            integrationTestImplementation "org.junit.jupiter:junit-jupiter-params:${rootProject.ext.dependencies.junit.version}"
            integrationTestRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${rootProject.ext.dependencies.junit.version}"
        }

        test {
            useJUnitPlatform()
        }

        task integrationTest(type: Test) {
            description = 'Runs integration tests.'
            group = 'verification'

            testClassesDirs = sourceSets.integrationTest.output.classesDirs
            classpath = sourceSets.integrationTest.runtimeClasspath
        }

        integrationTest.dependsOn jar
        check.dependsOn integrationTest

        integrationTest {
            useJUnitPlatform()
        }
        
        jar {
            manifest {
                attributes += [
                    'Implementation-Vendor': 'Thierry Wasylczenko'
                ]
            }
        }
    }
    
    def sfxPluginCallback = {
        evaluationDependsOn(':slideshowfx-plugin')
        
        sfxPlugin {
            bundle {
                vendor = "Thierry Wasylczenko"
            }
        }
        
        dependencies {
            implementation "org.apache.felix:org.apache.felix.framework:${rootProject.ext.dependencies.felix.version}"

            integrationTestImplementation project(':slideshowfx-osgi')
            integrationTestImplementation project(':slideshowfx-plugin').sourceSets.integrationTest.output
        }
    }

    def bintrayCallback = {
        bintray {
            user = System.properties['bintrayUserName'] ?: System.env['BINTRAY_USER_NAME']
            key = System.properties['bintrayApiKey'] ?: System.env['BINTRAY_API_KEY']

            configurations = ['archives']

            pkg {
                repo = 'SlideshowFX'
                name = project.name
                websiteUrl = 'https://slideshowfx.github.io'
                issueTrackerUrl = 'https://github.com/twasyl/SlideshowFX/issues'
                vcsUrl = 'https://github.com/twasyl/SlideshowFX.git'

                desc = project.description

                licenses = ['Apache-2.0']

                githubRepo = 'twasyl/SlideshowFX'
                githubReleaseNotesFile = 'CHANGELOG.textile'

                version {
                    name = rootProject.stripProjectVersion(project.version)
                    desc = project.description
                    released = new Date()
                    vcsTag = "v${rootProject.stripProjectVersion(project.version)}"
                }
            }
        }

        bintrayUpload.enabled = System.properties["${project.name}.publish"] ?: false
    }

    def jacocoCallback = {
        jacoco {
            toolVersion = "0.8.3"
        }

        jacocoTestReport {
            
            additionalSourceDirs = files(sourceSets.main.allJava.srcDirs)
            
            executionData fileTree("$buildDir/jacoco").matching {
                include "*.exec"
            }
            
            reports {
                csv.enabled false
                html.enabled true
                xml.enabled true
            }
        }
    }

    def sonarqubeCallback = {
        sonarqube {
            properties {
                def integrationTestsDirs = sourceSets.integrationTest.allSource.srcDirs.findAll { it.exists() }
                def jacocoIntegrationTestResult = "$buildDir/jacoco/${sourceSets.integrationTest.name}.exec"
                def junitIntegrationTestReport = "$buildDir/reports/tests/${sourceSets.integrationTest.name}"
                
                if (sourceSets.test.allJava.srcDirs.findAll { it.exists()}.isEmpty()) {
                    properties["sonar.tests"] = integrationTestsDirs
                    properties["sonar.jacoco.reportPaths"] = jacocoIntegrationTestResult
                    properties["sonar.junit.reportPaths"] = junitIntegrationTestReport
                } else {
                    properties["sonar.tests"] += integrationTestsDirs
                    properties["sonar.jacoco.reportPaths"] += jacocoIntegrationTestResult
                    properties["sonar.junit.reportPaths"] += junitIntegrationTestReport
                }
            }
        }
    }

    plugins.withType(JavaPlugin, javaCallback)
    plugins.withId('sfx-plugin', sfxPluginCallback)
    plugins.withId('com.jfrog.bintray', bintrayCallback)
    plugins.withId('jacoco', jacocoCallback)
    plugins.withId('org.sonarqube', sonarqubeCallback)
}

sonarqube {
    properties {
        property "sonar.host.url", System.properties['sonar.host.url'] ?: System.env['SONAR_HOST_URL']
        property "sonar.login", System.properties['sonar.login'] ?: System.env['SONAR_LOGIN']
        property "sonar.projectKey", System.properties['sonar.projectKey'] ?: System.env['SONAR_PROJECT_KEY']
        property "sonar.organization", System.properties['sonar.organization'] ?: System.env['SONAR_ORGANIZATION']
    }
}

tasks.sonarqube.dependsOn {
    subprojects.findAll { it.getPluginManager().hasPlugin('org.sonarqube') }.collect {
        [
                it.tasks.check
        ]
    }.flatten()
}

/**
 * Task listing the projects that have a SNAPSHOT a version. These projects will be printed on the console with their
 * version.
 */
task listSnapshotProjects {
    doLast {
        getSnapshotProjects().each { println "${it.name} => ${it.version}" }
    }
}

/**
 * Save as system properties in {@code gradle.properties} file the project that should be published. This task uses
 * {@link #getSnapshotProjects()} to determine which project should be published.
 */
task saveProjectsToBePublished {
    doLast {
        new File("$rootProject.projectDir/gradle.properties").withWriter { out ->
            getSnapshotProjects().findAll { rootProject.isPlugin(it) || it.name.equals('slideshowfx-setup') } each {
                out.println "systemProp.${it.name}.publish=true"
            }
        }
    }
}
